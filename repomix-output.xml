This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/.env.example
backend/.git/config
backend/.git/description
backend/.git/HEAD
backend/.git/hooks/applypatch-msg.sample
backend/.git/hooks/commit-msg.sample
backend/.git/hooks/fsmonitor-watchman.sample
backend/.git/hooks/post-update.sample
backend/.git/hooks/pre-applypatch.sample
backend/.git/hooks/pre-commit.sample
backend/.git/hooks/pre-merge-commit.sample
backend/.git/hooks/pre-push.sample
backend/.git/hooks/pre-rebase.sample
backend/.git/hooks/pre-receive.sample
backend/.git/hooks/prepare-commit-msg.sample
backend/.git/hooks/push-to-checkout.sample
backend/.git/hooks/sendemail-validate.sample
backend/.git/hooks/update.sample
backend/.git/info/exclude
backend/api-tests.http
backend/package.json
backend/src/app.js
backend/src/config/cors.js
backend/src/config/database.js
backend/src/controllers/authController.js
backend/src/controllers/expenseController.js
backend/src/middleware/auth.js
backend/src/middleware/errorHandler.js
backend/src/middleware/validation.js
backend/src/models/Expense.js
backend/src/models/User.js
backend/src/routes/authRoutes.js
backend/src/routes/expenseRoutes.js
backend/src/server.js
backend/test-api.http
backend/test-mongodb-connection.js
frontend/package.json
frontend/public/index.html
frontend/public/manifest.json
frontend/public/robots.txt
frontend/src/App.tsx
frontend/src/components/auth/LoginForm.tsx
frontend/src/components/auth/ProtectedRoute.tsx
frontend/src/components/auth/RegisterForm.tsx
frontend/src/components/common/ConfirmDialog.tsx
frontend/src/components/common/ErrorMessage.tsx
frontend/src/components/common/LoadingSpinner.tsx
frontend/src/components/expenses/ExpenseForm.tsx
frontend/src/components/expenses/ExpenseItem.tsx
frontend/src/components/expenses/ExpenseList.tsx
frontend/src/components/expenses/ExpenseStats.tsx
frontend/src/components/layout/Header.tsx
frontend/src/components/layout/Layout.tsx
frontend/src/components/layout/Sidebar.tsx
frontend/src/context/AuthContext.tsx
frontend/src/hooks/useAsync.ts
frontend/src/hooks/useAuth.ts
frontend/src/hooks/useExpenses.ts
frontend/src/index.tsx
frontend/src/pages/Dashboard.tsx
frontend/src/pages/Expenses.tsx
frontend/src/pages/Login.tsx
frontend/src/pages/Profile.tsx
frontend/src/pages/Register.tsx
frontend/src/services/api.ts
frontend/src/services/auth.service.ts
frontend/src/services/expense.service.ts
frontend/src/styles/globals.css
frontend/src/styles/theme.ts
frontend/src/types/index.ts
frontend/src/utils/constants.ts
frontend/src/utils/helpers.ts
frontend/src/utils/validators.ts
frontend/tsconfig.json
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.git/config">
[core]
	repositoryformatversion = 0
</file>

<file path="backend/.git/description">
Unnamed repository; edit this file 'description' to name the repository.
</file>

<file path="backend/.git/HEAD">
ref: refs/heads/main
</file>

<file path="backend/.git/hooks/applypatch-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:
</file>

<file path="backend/.git/hooks/commit-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}
</file>

<file path="backend/.git/hooks/fsmonitor-watchman.sample">
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}
</file>

<file path="backend/.git/hooks/post-update.sample">
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info
</file>

<file path="backend/.git/hooks/pre-applypatch.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:
</file>

<file path="backend/.git/hooks/pre-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --
</file>

<file path="backend/.git/hooks/pre-merge-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:
</file>

<file path="backend/.git/hooks/pre-push.sample">
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0
</file>

<file path="backend/.git/hooks/pre-rebase.sample">
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
</file>

<file path="backend/.git/hooks/pre-receive.sample">
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi
</file>

<file path="backend/.git/hooks/prepare-commit-msg.sample">
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi
</file>

<file path="backend/.git/hooks/push-to-checkout.sample">
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi
</file>

<file path="backend/.git/hooks/sendemail-validate.sample">
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi
</file>

<file path="backend/.git/hooks/update.sample">
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0
</file>

<file path="backend/.git/info/exclude">
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</file>

<file path="frontend/public/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
            name="description"
            content="Expense Tracker - Manage your finances"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <title>Expense Tracker</title>
</head>
<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<div id="root"></div>
</body>
</html>
</file>

<file path="frontend/public/manifest.json">
{
  "short_name": "Expense Tracker",
  "name": "Expense Tracker Application",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="frontend/public/robots.txt">
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
</file>

<file path="frontend/src/App.tsx">
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { AuthProvider } from './context/AuthContext';
import { ProtectedRoute } from './components/auth/ProtectedRoute';
import { Layout } from './components/layout/Layout';
import { Login } from './pages/Login';
import { Register } from './pages/Register';
import { Dashboard } from './pages/Dashboard';
import { Expenses } from './pages/Expenses';
import { Profile } from './pages/Profile';
import { theme } from './styles/theme';
import './styles/globals.css';

function App() {
    return (
        <ThemeProvider theme={theme}>
            <CssBaseline />
            <AuthProvider>
                <BrowserRouter>
                    <Routes>
                        <Route path="/login" element={<Login />} />
                        <Route path="/register" element={<Register />} />

                        <Route
                            path="/"
                            element={
                                <ProtectedRoute>
                                    <Layout />
                                </ProtectedRoute>
                            }
                        >
                            <Route index element={<Navigate to="/dashboard" replace />} />
                            <Route path="dashboard" element={<Dashboard />} />
                            <Route path="expenses" element={<Expenses />} />
                            <Route path="statistics" element={<Dashboard />} />
                            <Route path="profile" element={<Profile />} />
                        </Route>

                        <Route path="*" element={<Navigate to="/dashboard" replace />} />
                    </Routes>
                </BrowserRouter>
            </AuthProvider>
        </ThemeProvider>
    );
}

export default App;
</file>

<file path="frontend/src/components/auth/LoginForm.tsx">
import React from 'react';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import {
    TextField,
    Button,
    Box,
    CircularProgress,
} from '@mui/material';
import { LoginCredentials } from '../../types';
import { loginSchema } from '../../utils/validators';

interface LoginFormProps {
    onSubmit: (data: LoginCredentials) => Promise<void>;
    loading?: boolean;
}

export const LoginForm: React.FC<LoginFormProps> = ({ onSubmit, loading }) => {
    const {
        control,
        handleSubmit,
        formState: { errors },
    } = useForm<LoginCredentials>({
        resolver: yupResolver(loginSchema) as any,
        defaultValues: {
            email: '',
            password: '',
        },
    });

    return (
        <Box component="form" onSubmit={handleSubmit(onSubmit as any)} noValidate>
            <Controller
                name="email"
                control={control}
                render={({ field }) => (
                    <TextField
                        {...field}
                        margin="normal"
                        label="Email Address"
                        type="email"
                        autoComplete="email"
                        autoFocus
                        error={!!errors.email}
                        helperText={errors.email?.message}
                    />
                )}
            />

            <Controller
                name="password"
                control={control}
                render={({ field }) => (
                    <TextField
                        {...field}
                        margin="normal"
                        label="Password"
                        type="password"
                        autoComplete="current-password"
                        error={!!errors.password}
                        helperText={errors.password?.message}
                    />
                )}
            />

            <Button
                type="submit"
                fullWidth
                variant="contained"
                sx={{ mt: 3, mb: 2 }}
                disabled={loading}
            >
                {loading ? <CircularProgress size={24} /> : 'Sign In'}
            </Button>
        </Box>
    );
};
</file>

<file path="frontend/src/components/auth/ProtectedRoute.tsx">
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import { LoadingSpinner } from '../common/LoadingSpinner';

interface ProtectedRouteProps {
    children: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
    const { isAuthenticated, loading } = useAuth();
    const location = useLocation();

    if (loading) {
        return <LoadingSpinner fullScreen />;
    }

    if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
    }

    return <>{children}</>;
};
</file>

<file path="frontend/src/components/auth/RegisterForm.tsx">
import React from 'react';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import {
    TextField,
    Button,
    Box,
    CircularProgress,
} from '@mui/material';
import { RegisterCredentials } from '../../types';
import { registerSchema } from '../../utils/validators';

interface RegisterFormProps {
    onSubmit: (data: RegisterCredentials) => Promise<void>;
    loading?: boolean;
}

interface RegisterFormData extends RegisterCredentials {
    confirmPassword: string;
}

export const RegisterForm: React.FC<RegisterFormProps> = ({ onSubmit, loading }) => {
    const {
        control,
        handleSubmit,
        formState: { errors },
    } = useForm<RegisterFormData>({
        resolver: yupResolver(registerSchema) as any,
        defaultValues: {
            name: '',
            email: '',
            password: '',
            confirmPassword: '',
        },
    });

    const handleFormSubmit = (data: RegisterFormData) => {
        const { confirmPassword, ...registerData } = data;
        return onSubmit(registerData);
    };

    return (
        <Box component="form" onSubmit={handleSubmit(handleFormSubmit as any)} noValidate>
            <Controller
                name="name"
                control={control}
                render={({ field }) => (
                    <TextField
                        {...field}
                        margin="normal"
                        label="Full Name"
                        autoComplete="name"
                        autoFocus
                        error={!!errors.name}
                        helperText={errors.name?.message}
                    />
                )}
            />

            <Controller
                name="email"
                control={control}
                render={({ field }) => (
                    <TextField
                        {...field}
                        margin="normal"
                        label="Email Address"
                        type="email"
                        autoComplete="email"
                        error={!!errors.email}
                        helperText={errors.email?.message}
                    />
                )}
            />

            <Controller
                name="password"
                control={control}
                render={({ field }) => (
                    <TextField
                        {...field}
                        margin="normal"
                        label="Password"
                        type="password"
                        autoComplete="new-password"
                        error={!!errors.password}
                        helperText={errors.password?.message}
                    />
                )}
            />

            <Controller
                name="confirmPassword"
                control={control}
                render={({ field }) => (
                    <TextField
                        {...field}
                        margin="normal"
                        label="Confirm Password"
                        type="password"
                        autoComplete="new-password"
                        error={!!errors.confirmPassword}
                        helperText={errors.confirmPassword?.message}
                    />
                )}
            />

            <Button
                type="submit"
                fullWidth
                variant="contained"
                sx={{ mt: 3, mb: 2 }}
                disabled={loading}
            >
                {loading ? <CircularProgress size={24} /> : 'Sign Up'}
            </Button>
        </Box>
    );
};
</file>

<file path="frontend/src/components/common/ConfirmDialog.tsx">
import React from 'react';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogContentText,
    DialogActions,
    Button,
} from '@mui/material';

interface ConfirmDialogProps {
    open: boolean;
    title: string;
    message: string;
    confirmText?: string;
    cancelText?: string;
    onConfirm: () => void;
    onCancel: () => void;
}

export const ConfirmDialog: React.FC<ConfirmDialogProps> = ({
                                                                open,
                                                                title,
                                                                message,
                                                                confirmText = 'Confirm',
                                                                cancelText = 'Cancel',
                                                                onConfirm,
                                                                onCancel,
                                                            }) => {
    return (
        <Dialog open={open} onClose={onCancel} maxWidth="xs" fullWidth>
            <DialogTitle>{title}</DialogTitle>
            <DialogContent>
                <DialogContentText>{message}</DialogContentText>
            </DialogContent>
            <DialogActions>
                <Button onClick={onCancel} color="inherit">
                    {cancelText}
                </Button>
                <Button onClick={onConfirm} color="primary" variant="contained">
                    {confirmText}
                </Button>
            </DialogActions>
        </Dialog>
    );
};
</file>

<file path="frontend/src/components/common/ErrorMessage.tsx">
import React from 'react';
import { Alert, AlertTitle } from '@mui/material';

interface ErrorMessageProps {
    error: Error | string | null;
    title?: string;
}

export const ErrorMessage: React.FC<ErrorMessageProps> = ({ error, title }) => {
    if (!error) return null;

    const message = typeof error === 'string' ? error : error.message;

    return (
        <Alert severity="error" sx={{ mb: 2 }}>
            {title && <AlertTitle>{title}</AlertTitle>}
            {message}
        </Alert>
    );
};
</file>

<file path="frontend/src/components/common/LoadingSpinner.tsx">
import React from 'react';
import { Box, CircularProgress } from '@mui/material';

interface LoadingSpinnerProps {
    size?: number;
    fullScreen?: boolean;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
                                                                  size = 40,
                                                                  fullScreen = false
                                                              }) => {
    if (fullScreen) {
        return (
            <Box
                display="flex"
                alignItems="center"
                justifyContent="center"
                minHeight="100vh"
            >
                <CircularProgress size={size} />
            </Box>
        );
    }

    return <CircularProgress size={size} />;
};
</file>

<file path="frontend/src/components/expenses/ExpenseForm.tsx">
import React, { useState, useEffect } from 'react';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    Button,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Box,
    InputAdornment,
    SelectChangeEvent
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import { Expense, ExpenseFormData, ExpenseCategory } from '../../types';
import { expenseSchema } from '../../utils/validators';
import { EXPENSE_CATEGORIES } from '../../utils/constants';
import { formatDateForInput } from '../../utils/helpers';

interface ExpenseFormProps {
    open: boolean;
    onClose: () => void;
    onSubmit: (data: ExpenseFormData) => Promise<void>;
    expense?: Expense | null;
}

export const ExpenseForm: React.FC<ExpenseFormProps> = ({
                                                            open,
                                                            onClose,
                                                            onSubmit,
                                                            expense
                                                        }) => {
    const [loading, setLoading] = useState(false);

    const {
        control,
        handleSubmit,
        reset,
        formState: { errors }
    } = useForm<ExpenseFormData>({
        resolver: yupResolver(expenseSchema) as any,
        defaultValues: {
            title: '',
            amount: 0,
            category: 'Other' as ExpenseCategory,
            description: '',
            date: formatDateForInput(new Date()),
            isRecurring: false,
            tags: []
        }
    });

    useEffect(() => {
        if (expense) {
            reset({
                title: expense.title,
                amount: expense.amount,
                category: expense.category,
                description: expense.description ?? '',
                date: formatDateForInput(expense.date),
                isRecurring: expense.isRecurring,
                recurringInterval: expense.recurringInterval,
                tags: expense.tags ?? []
            });
        } else {
            reset({
                title: '',
                amount: 0,
                category: 'Other' as ExpenseCategory,
                description: '',
                date: formatDateForInput(new Date()),
                isRecurring: false,
                tags: []
            });
        }
    }, [expense, reset]);

    const handleFormSubmit = async (data: ExpenseFormData) => {
        setLoading(true);
        try {
            await onSubmit(data);
            onClose();
        } catch (error) {
            console.error('Error submitting expense:', error);
        } finally {
            setLoading(false);
        }
    };

    return (
        <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
            <form onSubmit={handleSubmit(handleFormSubmit as any)}>
                <DialogTitle>
                    {expense ? 'Edit Expense' : 'Add New Expense'}
                </DialogTitle>
                <DialogContent>
                    <Box sx={{ pt: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
                        <Controller
                            name="title"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    label="Title"
                                    fullWidth
                                    error={!!errors.title}
                                    helperText={errors.title?.message ?? ''}
                                />
                            )}
                        />

                        <Controller
                            name="amount"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    label="Amount"
                                    type="number"
                                    fullWidth
                                    InputProps={{
                                        startAdornment: <InputAdornment position="start">$</InputAdornment>
                                    }}
                                    error={!!errors.amount}
                                    helperText={errors.amount?.message ?? ''}
                                    inputProps={{ step: 0.01, min: 0 }}
                                />
                            )}
                        />

                        <Controller
                            name="category"
                            control={control}
                            render={({ field }) => (
                                <FormControl fullWidth error={!!errors.category}>
                                    <InputLabel>Category</InputLabel>
                                    <Select
                                        {...field}
                                        label="Category"
                                        value={field.value}
                                        onChange={(e: SelectChangeEvent) => field.onChange(e.target.value)}
                                    >
                                        {EXPENSE_CATEGORIES.map((cat) => (
                                            <MenuItem key={cat} value={cat}>
                                                {cat}
                                            </MenuItem>
                                        ))}
                                    </Select>
                                </FormControl>
                            )}
                        />

                        <Controller
                            name="date"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    label="Date"
                                    type="date"
                                    fullWidth
                                    InputLabelProps={{ shrink: true }}
                                    error={!!errors.date}
                                    helperText={errors.date?.message ?? ''}
                                />
                            )}
                        />

                        <Controller
                            name="description"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    label="Description (Optional)"
                                    multiline
                                    rows={3}
                                    fullWidth
                                    error={!!errors.description}
                                    helperText={errors.description?.message ?? ''}
                                />
                            )}
                        />
                    </Box>
                </DialogContent>
                <DialogActions>
                    <Button onClick={onClose}>Cancel</Button>
                    <Button type="submit" variant="contained" disabled={loading}>
                        {loading ? 'Saving...' : expense ? 'Update' : 'Add'}
                    </Button>
                </DialogActions>
            </form>
        </Dialog>
    );
};
</file>

<file path="frontend/src/components/expenses/ExpenseItem.tsx">
import React from 'react';
import {
    ListItem,
    ListItemText,
    ListItemSecondaryAction,
    IconButton,
    Chip,
    Typography,
    Box
} from '@mui/material';
import { Edit, Delete } from '@mui/icons-material';
import { Expense } from '../../types';
import { formatCurrency, formatDate } from '../../utils/helpers';
import { CATEGORY_COLORS } from '../../utils/constants';

interface ExpenseItemProps {
    expense: Expense;
    onEdit: (expense: Expense) => void;
    onDelete: (id: string) => void;
}

export const ExpenseItem: React.FC<ExpenseItemProps> = ({
                                                            expense,
                                                            onEdit,
                                                            onDelete
                                                        }) => {
    return (
        <ListItem>
            <ListItemText
                primary={
                    <Box display="flex" alignItems="center" gap={1}>
                        <Typography variant="body1">{expense.title}</Typography>
                        <Chip
                            label={expense.category}
                            size="small"
                            style={{
                                backgroundColor: CATEGORY_COLORS[expense.category],
                                color: 'white'
                            }}
                        />
                    </Box>
                }
                secondary={
                    <Box>
                        <Typography variant="body2" color="text.secondary">
                            {formatDate(expense.date)}  {formatCurrency(expense.amount)}
                        </Typography>
                        {expense.description && (
                            <Typography variant="body2" color="text.secondary">
                                {expense.description}
                            </Typography>
                        )}
                    </Box>
                }
            />
            <ListItemSecondaryAction>
                <IconButton edge="end" onClick={() => onEdit(expense)}>
                    <Edit />
                </IconButton>
                <IconButton edge="end" onClick={() => onDelete(expense._id)}>
                    <Delete />
                </IconButton>
            </ListItemSecondaryAction>
        </ListItem>
    );
};
</file>

<file path="frontend/src/components/expenses/ExpenseList.tsx">
import React, { useState } from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    IconButton,
    Chip,
    Box,
    Typography,
    TablePagination
} from '@mui/material';
import {
    Edit as EditIcon,
    Delete as DeleteIcon
} from '@mui/icons-material';
import { Expense } from '../../types';
import { formatCurrency, formatDate } from '../../utils/helpers';
import { CATEGORY_COLORS } from '../../utils/constants';
import { ConfirmDialog } from '../common/ConfirmDialog';

interface ExpenseListProps {
    expenses: Expense[];
    onEdit: (expense: Expense) => void;
    onDelete: (id: string) => void;
}

export const ExpenseList: React.FC<ExpenseListProps> = ({
                                                            expenses,
                                                            onEdit,
                                                            onDelete
                                                        }) => {
    const [page, setPage] = useState(0);
    const [rowsPerPage, setRowsPerPage] = useState(10);
    const [deleteDialog, setDeleteDialog] = useState<{
        open: boolean;
        expenseId: string | null;
        expenseTitle: string;
    }>({
        open: false,
        expenseId: null,
        expenseTitle: ''
    });

    const handleChangePage = (event: unknown, newPage: number) => {
        setPage(newPage);
    };

    const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
        setRowsPerPage(parseInt(event.target.value, 10));
        setPage(0);
    };

    const handleDeleteClick = (expense: Expense) => {
        setDeleteDialog({
            open: true,
            expenseId: expense._id,
            expenseTitle: expense.title
        });
    };

    const handleDeleteConfirm = () => {
        if (deleteDialog.expenseId) {
            onDelete(deleteDialog.expenseId);
        }
        setDeleteDialog({ open: false, expenseId: null, expenseTitle: '' });
    };

    const handleDeleteCancel = () => {
        setDeleteDialog({ open: false, expenseId: null, expenseTitle: '' });
    };

    if (expenses.length === 0) {
        return (
            <Box
                sx={{
                    textAlign: 'center',
                    py: 8,
                    px: 2,
                    backgroundColor: 'background.paper',
                    borderRadius: 1
                }}
            >
                <Typography variant="h6" color="text.secondary">
                    No expenses found
                </Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                    Start by adding your first expense
                </Typography>
            </Box>
        );
    }

    const paginatedExpenses = expenses.slice(
        page * rowsPerPage,
        page * rowsPerPage + rowsPerPage
    );

    return (
        <>
            <TableContainer component={Paper}>
                <Table>
                    <TableHead>
                        <TableRow>
                            <TableCell>Date</TableCell>
                            <TableCell>Title</TableCell>
                            <TableCell>Category</TableCell>
                            <TableCell align="right">Amount</TableCell>
                            <TableCell>Description</TableCell>
                            <TableCell align="center">Actions</TableCell>
                        </TableRow>
                    </TableHead>
                    <TableBody>
                        {paginatedExpenses.map((expense: Expense) => (
                            <TableRow key={expense._id} hover>
                                <TableCell>{formatDate(expense.date)}</TableCell>
                                <TableCell>{expense.title}</TableCell>
                                <TableCell>
                                    <Chip
                                        label={expense.category}
                                        size="small"
                                        style={{
                                            backgroundColor: CATEGORY_COLORS[expense.category] ?? '#969696',
                                            color: 'white'
                                        }}
                                    />
                                </TableCell>
                                <TableCell align="right">
                                    {formatCurrency(expense.amount)}
                                </TableCell>
                                <TableCell>{expense.description ?? '-'}</TableCell>
                                <TableCell align="center">
                                    <IconButton
                                        size="small"
                                        onClick={() => onEdit(expense)}
                                        color="primary"
                                    >
                                        <EditIcon />
                                    </IconButton>
                                    <IconButton
                                        size="small"
                                        onClick={() => handleDeleteClick(expense)}
                                        color="error"
                                    >
                                        <DeleteIcon />
                                    </IconButton>
                                </TableCell>
                            </TableRow>
                        ))}
                    </TableBody>
                </Table>
                <TablePagination
                    rowsPerPageOptions={[5, 10, 25]}
                    component="div"
                    count={expenses.length}
                    rowsPerPage={rowsPerPage}
                    page={page}
                    onPageChange={handleChangePage}
                    onRowsPerPageChange={handleChangeRowsPerPage}
                />
            </TableContainer>

            <ConfirmDialog
                open={deleteDialog.open}
                title="Delete Expense"
                message={`Are you sure you want to delete "${deleteDialog.expenseTitle}"?`}
                confirmText="Delete"
                cancelText="Cancel"
                onConfirm={handleDeleteConfirm}
                onCancel={handleDeleteCancel}
            />
        </>
    );
};
</file>

<file path="frontend/src/components/expenses/ExpenseStats.tsx">
import React from 'react';
import {
    Paper,
    Typography,
    Box,
    Grid,
    Card,
    CardContent,
    useTheme
} from '@mui/material';
import { ExpenseStats as ExpenseStatsType, CategoryStats, MonthlyStats } from '../../types';
import { formatCurrency } from '../../utils/helpers';
import { MONTHS } from '../../utils/constants';

interface ExpenseStatsProps {
    stats: ExpenseStatsType;
}

export const ExpenseStats: React.FC<ExpenseStatsProps> = ({ stats }) => {
    const theme = useTheme();

    return (
        <Grid container spacing={3}>
            <Grid item xs={12}>
                <Typography variant="h5" gutterBottom>
                    Expense Statistics
                </Typography>
            </Grid>

            <Grid item xs={12}>
                <Grid container spacing={2}>
                    {stats.categoryStats.map((stat: CategoryStats) => (
                        <Grid item xs={12} sm={6} md={3} key={stat.category}>
                            <Card>
                                <CardContent>
                                    <Typography color="textSecondary" gutterBottom>
                                        {stat.category}
                                    </Typography>
                                    <Typography variant="h5">
                                        {formatCurrency(stat.totalAmount)}
                                    </Typography>
                                    <Typography variant="body2" color="textSecondary">
                                        {stat.count} transactions
                                    </Typography>
                                    <Typography variant="body2" color="textSecondary">
                                        Avg: {formatCurrency(stat.avgAmount)}
                                    </Typography>
                                </CardContent>
                            </Card>
                        </Grid>
                    ))}
                </Grid>
            </Grid>

            <Grid item xs={12}>
                <Paper sx={{ p: 3 }}>
                    <Typography variant="h6" gutterBottom>
                        Monthly Breakdown
                    </Typography>
                    <Grid container spacing={2}>
                        {stats.monthlyStats.map((stat: MonthlyStats) => (
                            <Grid item xs={12} sm={6} md={4} key={`${stat.year}-${stat.month}`}>
                                <Box sx={{ p: 2, border: '1px solid #e0e0e0', borderRadius: 1 }}>
                                    <Typography variant="body2" color="textSecondary">
                                        {MONTHS[stat.month - 1]} {stat.year}
                                    </Typography>
                                    <Typography variant="h6">
                                        {formatCurrency(stat.totalAmount)}
                                    </Typography>
                                    <Typography variant="body2" color="textSecondary">
                                        {stat.count} expenses
                                    </Typography>
                                </Box>
                            </Grid>
                        ))}
                    </Grid>
                </Paper>
            </Grid>
        </Grid>
    );
};
</file>

<file path="frontend/src/components/layout/Header.tsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';
import {
    AppBar,
    Toolbar,
    Typography,
    IconButton,
    Menu,
    MenuItem,
    Avatar,
    Box,
} from '@mui/material';
import {
    Menu as MenuIcon,
    Logout,
    Person,
} from '@mui/icons-material';
import { useAuth } from '../../hooks/useAuth';

interface HeaderProps {
    onMenuClick?: () => void;
}

export const Header: React.FC<HeaderProps> = ({ onMenuClick }) => {
    const navigate = useNavigate();
    const { user, logout } = useAuth();
    const [anchorEl, setAnchorEl] = React.useState<null | HTMLElement>(null);

    const handleMenu = (event: React.MouseEvent<HTMLElement>) => {
        setAnchorEl(event.currentTarget);
    };

    const handleClose = () => {
        setAnchorEl(null);
    };

    const handleProfile = () => {
        handleClose();
        navigate('/profile');
    };

    const handleLogout = () => {
        handleClose();
        logout();
    };

    return (
        <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
            <Toolbar>
                {onMenuClick && (
                    <IconButton
                        color="inherit"
                        aria-label="open drawer"
                        edge="start"
                        onClick={onMenuClick}
                        sx={{ mr: 2 }}
                    >
                        <MenuIcon />
                    </IconButton>
                )}

                <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
                    Expense Tracker
                </Typography>

                {user && (
                    <Box>
                        <IconButton
                            size="large"
                            aria-label="account of current user"
                            aria-controls="menu-appbar"
                            aria-haspopup="true"
                            onClick={handleMenu}
                            color="inherit"
                        >
                            <Avatar sx={{ width: 32, height: 32 }}>
                                {user.name.charAt(0).toUpperCase()}
                            </Avatar>
                        </IconButton>
                        <Menu
                            id="menu-appbar"
                            anchorEl={anchorEl}
                            anchorOrigin={{
                                vertical: 'bottom',
                                horizontal: 'right',
                            }}
                            keepMounted
                            transformOrigin={{
                                vertical: 'top',
                                horizontal: 'right',
                            }}
                            open={Boolean(anchorEl)}
                            onClose={handleClose}
                        >
                            <MenuItem onClick={handleProfile}>
                                <Person sx={{ mr: 1 }} /> Profile
                            </MenuItem>
                            <MenuItem onClick={handleLogout}>
                                <Logout sx={{ mr: 1 }} /> Logout
                            </MenuItem>
                        </Menu>
                    </Box>
                )}
            </Toolbar>
        </AppBar>
    );
};
</file>

<file path="frontend/src/components/layout/Layout.tsx">
import React, { useState } from 'react';
import { Outlet } from 'react-router-dom';
import { Box, Toolbar, useTheme, useMediaQuery } from '@mui/material';
import { Header } from './Header';
import { Sidebar } from './Sidebar';

export const Layout: React.FC = () => {
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));
    const [mobileOpen, setMobileOpen] = useState(false);

    const handleDrawerToggle = () => {
        setMobileOpen(!mobileOpen);
    };

    return (
        <Box sx={{ display: 'flex' }}>
            <Header onMenuClick={isMobile ? handleDrawerToggle : undefined} />
            <Sidebar
                open={isMobile ? mobileOpen : true}
                variant={isMobile ? 'temporary' : 'permanent'}
                onClose={handleDrawerToggle}
            />
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    p: 3,
                    width: { sm: `calc(100% - 240px)` },
                    minHeight: '100vh',
                    backgroundColor: 'background.default',
                }}
            >
                <Toolbar />
                <Outlet />
            </Box>
        </Box>
    );
};
</file>

<file path="frontend/src/components/layout/Sidebar.tsx">
import React from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import {
    Drawer,
    List,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    Toolbar,
    Box,
} from '@mui/material';
import {
    Dashboard,
    Receipt,
    BarChart,
    Person,
} from '@mui/icons-material';

const drawerWidth = 240;

interface SidebarProps {
    open?: boolean;
    variant?: 'permanent' | 'persistent' | 'temporary';
    onClose?: () => void;
}

const menuItems = [
    { text: 'Dashboard', icon: <Dashboard />, path: '/dashboard' },
    { text: 'Expenses', icon: <Receipt />, path: '/expenses' },
    { text: 'Statistics', icon: <BarChart />, path: '/statistics' },
    { text: 'Profile', icon: <Person />, path: '/profile' },
];

export const Sidebar: React.FC<SidebarProps> = ({
                                                    open = true,
                                                    variant = 'permanent',
                                                    onClose
                                                }) => {
    const navigate = useNavigate();
    const location = useLocation();

    const handleNavigate = (path: string) => {
        navigate(path);
        if (onClose) onClose();
    };

    return (
        <Drawer
            variant={variant}
            open={open}
            onClose={onClose}
            sx={{
                width: drawerWidth,
                flexShrink: 0,
                '& .MuiDrawer-paper': {
                    width: drawerWidth,
                    boxSizing: 'border-box',
                },
            }}
        >
            <Toolbar />
            <Box sx={{ overflow: 'auto' }}>
                <List>
                    {menuItems.map((item) => (
                        <ListItem key={item.text} disablePadding>
                            <ListItemButton
                                selected={location.pathname === item.path}
                                onClick={() => handleNavigate(item.path)}
                            >
                                <ListItemIcon>{item.icon}</ListItemIcon>
                                <ListItemText primary={item.text} />
                            </ListItemButton>
                        </ListItem>
                    ))}
                </List>
            </Box>
        </Drawer>
    );
};
</file>

<file path="frontend/src/context/AuthContext.tsx">
import React, { createContext, useState, useEffect, ReactNode } from 'react';
import authService from '../services/auth.service';
import { User, LoginCredentials, RegisterCredentials, AuthState } from '../types';

interface AuthContextValue extends AuthState {
    login: (credentials: LoginCredentials) => Promise<void>;
    register: (credentials: RegisterCredentials) => Promise<void>;
    logout: () => void;
    updateUser: (user: User) => void;
}

export const AuthContext = createContext<AuthContextValue | null>(null);

interface AuthProviderProps {
    children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
    const [state, setState] = useState<AuthState>({
        user: null,
        token: null,
        isAuthenticated: false,
        loading: true,
    });

    useEffect(() => {
        const initAuth = async () => {
            const token = authService.getStoredToken();
            const user = authService.getStoredUser();

            if (token && user) {
                try {
                    const currentUser = await authService.getCurrentUser();
                    setState({
                        user: currentUser,
                        token,
                        isAuthenticated: true,
                        loading: false,
                    });
                } catch (error) {
                    authService.logout();
                    setState({
                        user: null,
                        token: null,
                        isAuthenticated: false,
                        loading: false,
                    });
                }
            } else {
                setState(prev => ({ ...prev, loading: false }));
            }
        };

        initAuth();
    }, []);

    const login = async (credentials: LoginCredentials) => {
        const { user, token } = await authService.login(credentials);
        setState({
            user,
            token,
            isAuthenticated: true,
            loading: false,
        });
    };

    const register = async (credentials: RegisterCredentials) => {
        const { user, token } = await authService.register(credentials);
        setState({
            user,
            token,
            isAuthenticated: true,
            loading: false,
        });
    };

    const logout = () => {
        authService.logout();
        setState({
            user: null,
            token: null,
            isAuthenticated: false,
            loading: false,
        });
    };

    const updateUser = (user: User) => {
        setState(prev => ({ ...prev, user }));
        localStorage.setItem('user', JSON.stringify(user));
    };

    const value: AuthContextValue = {
        ...state,
        login,
        register,
        logout,
        updateUser,
    };

    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};
</file>

<file path="frontend/src/hooks/useAsync.ts">
import { useState, useCallback, useEffect } from 'react';

interface AsyncState<T> {
    data: T | null;
    error: Error | null;
    loading: boolean;
}

export function useAsync<T>() {
    const [state, setState] = useState<AsyncState<T>>({
        data: null,
        error: null,
        loading: false,
    });

    const execute = useCallback(async (asyncFunction: () => Promise<T>) => {
        setState({ data: null, error: null, loading: true });

        try {
            const data = await asyncFunction();
            setState({ data, error: null, loading: false });
            return data;
        } catch (error) {
            setState({ data: null, error: error as Error, loading: false });
            throw error;
        }
    }, []);

    return { ...state, execute };
}

export function useAsyncEffect<T>(
    asyncFunction: () => Promise<T>,
    deps: React.DependencyList = []
) {
    const { execute, ...state } = useAsync<T>();

    useEffect(() => {
        execute(asyncFunction);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);

    return state;
}
</file>

<file path="frontend/src/hooks/useAuth.ts">
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext';

export const useAuth = () => {
    const context = useContext(AuthContext);

    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }

    return context;
};
</file>

<file path="frontend/src/hooks/useExpenses.ts">
import { useState, useEffect, useCallback } from 'react';
import expenseService from '../services/expense.service';
import { Expense, ExpenseFormData } from '../types';

interface UseExpensesOptions {
    autoFetch?: boolean;
    category?: string;
    startDate?: string;
    endDate?: string;
    limit?: number;
    page?: number;
}

export function useExpenses(options: UseExpensesOptions = {}) {
    const { autoFetch = true, category, startDate, endDate, limit, page } = options;

    const [expenses, setExpenses] = useState<Expense[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<Error | null>(null);
    const [totalAmount, setTotalAmount] = useState(0);
    const [pagination, setPagination] = useState({
        page: 1,
        limit: 50,
        pages: 1,
        total: 0,
    });

    const fetchExpenses = useCallback(async () => {
        setLoading(true);
        setError(null);

        try {
            const params = {
                category,
                startDate,
                endDate,
                limit,
                page
            };

            const response = await expenseService.getExpenses(params);
            setExpenses(response.data ?? []);
            setTotalAmount(response.totalAmount ?? 0);
            if (response.pagination) {
                setPagination({
                    page: response.pagination.page,
                    limit: response.pagination.limit,
                    pages: response.pagination.pages,
                    total: response.pagination.total ?? 0
                });
            }
        } catch (error) {
            setError(error as Error);
            setExpenses([]);
            setTotalAmount(0);
        } finally {
            setLoading(false);
        }
    }, [category, startDate, endDate, limit, page]);

    const createExpense = useCallback(async (data: ExpenseFormData) => {
        const newExpense = await expenseService.createExpense(data);
        setExpenses(prev => [newExpense, ...prev]);
        setTotalAmount(prev => prev + newExpense.amount);
        return newExpense;
    }, []);

    const updateExpense = useCallback(async (id: string, data: Partial<ExpenseFormData>) => {
        const updatedExpense = await expenseService.updateExpense(id, data);
        setExpenses(prev =>
            prev.map(exp => exp._id === id ? updatedExpense : exp)
        );
        // Recalculate total if amount changed
        const oldExpense = expenses.find(exp => exp._id === id);
        if (oldExpense && oldExpense.amount !== updatedExpense.amount) {
            setTotalAmount(prev => prev - oldExpense.amount + updatedExpense.amount);
        }
        return updatedExpense;
    }, [expenses]);

    const deleteExpense = useCallback(async (id: string) => {
        const expense = expenses.find(exp => exp._id === id);
        if (expense) {
            await expenseService.deleteExpense(id);
            setExpenses(prev => prev.filter(exp => exp._id !== id));
            setTotalAmount(prev => prev - expense.amount);
        }
    }, [expenses]);

    useEffect(() => {
        if (autoFetch) {
            fetchExpenses();
        }
    }, [autoFetch, fetchExpenses]);

    return {
        expenses,
        loading,
        error,
        totalAmount,
        pagination,
        fetchExpenses,
        createExpense,
        updateExpense,
        deleteExpense,
    };
}
</file>

<file path="frontend/src/index.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './styles/globals.css';
import App from './App';

const root = ReactDOM.createRoot(
    document.getElementById('root') as HTMLElement
);

root.render(
    <React.StrictMode>
        <App />
    </React.StrictMode>
);

// Add this export to make it a module
export {};
</file>

<file path="frontend/src/pages/Dashboard.tsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';
import {
    Grid,
    Paper,
    Typography,
    Box,
    Button,
    Card,
    CardContent,
} from '@mui/material';
import {
    Add as AddIcon,
    TrendingUp,
    Receipt,
    AccountBalance,
} from '@mui/icons-material';
import { useAuth } from '../hooks/useAuth';
import { useExpenses } from '../hooks/useExpenses';
import { formatCurrency, getCurrentMonthRange } from '../utils/helpers';
import { LoadingSpinner } from '../components/common/LoadingSpinner';
import { ErrorMessage } from '../components/common/ErrorMessage';

export const Dashboard: React.FC = () => {
    const navigate = useNavigate();
    const { user } = useAuth();
    const { start, end } = getCurrentMonthRange();

    const { expenses, totalAmount, loading, error } = useExpenses({
        startDate: start.toISOString(),
        endDate: end.toISOString(),
    });

    if (loading) return <LoadingSpinner fullScreen />;
    if (error) return <ErrorMessage error={error} />;

    const stats = [
        {
            title: 'Total Expenses',
            value: formatCurrency(totalAmount),
            icon: <AccountBalance />,
            color: '#4F46E5',
        },
        {
            title: 'Number of Expenses',
            value: expenses.length.toString(),
            icon: <Receipt />,
            color: '#10B981',
        },
        {
            title: 'Average Expense',
            value: formatCurrency(expenses.length > 0 ? totalAmount / expenses.length : 0),
            icon: <TrendingUp />,
            color: '#F59E0B',
        },
    ];

    return (
        <Box>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
                <Typography variant="h4">
                    Welcome back, {user?.name}!
                </Typography>
                <Button
                    variant="contained"
                    startIcon={<AddIcon />}
                    onClick={() => navigate('/expenses')}
                >
                    Add Expense
                </Button>
            </Box>

            <Grid container spacing={3}>
                {stats.map((stat, index) => (
                    <Grid item xs={12} sm={6} md={4} key={index}>
                        <Card>
                            <CardContent>
                                <Box display="flex" alignItems="center" mb={2}>
                                    <Box
                                        sx={{
                                            backgroundColor: stat.color,
                                            color: 'white',
                                            p: 1,
                                            borderRadius: 2,
                                            mr: 2,
                                        }}
                                    >
                                        {stat.icon}
                                    </Box>
                                    <Typography color="textSecondary" variant="body2">
                                        {stat.title}
                                    </Typography>
                                </Box>
                                <Typography variant="h5" component="div">
                                    {stat.value}
                                </Typography>
                            </CardContent>
                        </Card>
                    </Grid>
                ))}

                <Grid item xs={12}>
                    <Paper sx={{ p: 3 }}>
                        <Typography variant="h6" gutterBottom>
                            Recent Expenses
                        </Typography>
                        {expenses.length === 0 ? (
                            <Typography color="textSecondary">
                                No expenses found for this month. Start by adding your first expense!
                            </Typography>
                        ) : (
                            <Typography>
                                You have {expenses.length} expenses this month totaling {formatCurrency(totalAmount)}.
                            </Typography>
                        )}
                    </Paper>
                </Grid>
            </Grid>
        </Box>
    );
};
</file>

<file path="frontend/src/pages/Expenses.tsx">
import React, { useState } from 'react';
import {
    Box,
    Button,
    Typography,
    Paper,
    Grid
} from '@mui/material';
import { Add as AddIcon } from '@mui/icons-material';
import { useExpenses } from '../hooks/useExpenses';
import { ExpenseForm } from '../components/expenses/ExpenseForm';
import { ExpenseList } from '../components/expenses/ExpenseList';
import { LoadingSpinner } from '../components/common/LoadingSpinner';
import { ErrorMessage } from '../components/common/ErrorMessage';
import { Expense, ExpenseFormData } from '../types';
import { formatCurrency } from '../utils/helpers';

export const Expenses: React.FC = () => {
    const {
        expenses,
        loading,
        error,
        totalAmount,
        createExpense,
        updateExpense,
        deleteExpense
    } = useExpenses();

    const [formOpen, setFormOpen] = useState(false);
    const [editingExpense, setEditingExpense] = useState<Expense | null>(null);

    const handleAdd = () => {
        setEditingExpense(null);
        setFormOpen(true);
    };

    const handleEdit = (expense: Expense) => {
        setEditingExpense(expense);
        setFormOpen(true);
    };

    const handleFormSubmit = async (data: ExpenseFormData) => {
        try {
            if (editingExpense) {
                await updateExpense(editingExpense._id, data);
            } else {
                await createExpense(data);
            }
            setFormOpen(false);
            setEditingExpense(null);
        } catch (error) {
            console.error('Error saving expense:', error);
            // You might want to show an error message to the user here
        }
    };

    const handleFormClose = () => {
        setFormOpen(false);
        setEditingExpense(null);
    };

    if (loading) return <LoadingSpinner fullScreen />;
    if (error) return <ErrorMessage error={error} />;

    return (
        <Box>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
                <Typography variant="h4">Expenses</Typography>
                <Button
                    variant="contained"
                    startIcon={<AddIcon />}
                    onClick={handleAdd}
                >
                    Add Expense
                </Button>
            </Box>

            <Grid container spacing={3} sx={{ mb: 3 }}>
                <Grid item xs={12} sm={6} md={3}>
                    <Paper sx={{ p: 2 }}>
                        <Typography variant="body2" color="text.secondary">
                            Total Expenses
                        </Typography>
                        <Typography variant="h5">
                            {formatCurrency(totalAmount)}
                        </Typography>
                    </Paper>
                </Grid>
                <Grid item xs={12} sm={6} md={3}>
                    <Paper sx={{ p: 2 }}>
                        <Typography variant="body2" color="text.secondary">
                            Number of Expenses
                        </Typography>
                        <Typography variant="h5">
                            {expenses.length}
                        </Typography>
                    </Paper>
                </Grid>
            </Grid>

            <ExpenseList
                expenses={expenses}
                onEdit={handleEdit}
                onDelete={deleteExpense}
            />

            <ExpenseForm
                open={formOpen}
                onClose={handleFormClose}
                onSubmit={handleFormSubmit}
                expense={editingExpense}
            />
        </Box>
    );
};
</file>

<file path="frontend/src/pages/Login.tsx">
import React, { useState } from 'react';
import { Link as RouterLink, useNavigate, useLocation } from 'react-router-dom';
import {
    Container,
    Paper,
    Box,
    Typography,
    Link,
    Alert,
} from '@mui/material';
import { LoginForm } from '../components/auth/LoginForm';
import { useAuth } from '../hooks/useAuth';
import { LoginCredentials } from '../types';

export const Login: React.FC = () => {
    const navigate = useNavigate();
    const location = useLocation();
    const { login } = useAuth();
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState(false);

    const from = (location.state as any)?.from?.pathname || '/dashboard';

    const handleLogin = async (data: LoginCredentials) => {
        setError(null);
        setLoading(true);

        try {
            await login(data);
            navigate(from, { replace: true });
        } catch (err: any) {
            setError(err.message || 'Failed to login');
        } finally {
            setLoading(false);
        }
    };

    return (
        <Container component="main" maxWidth="xs">
            <Box
                sx={{
                    marginTop: 8,
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                }}
            >
                <Paper elevation={3} sx={{ p: 4, width: '100%' }}>
                    <Typography component="h1" variant="h5" align="center">
                        Sign In
                    </Typography>

                    {error && (
                        <Alert severity="error" sx={{ mt: 2 }}>
                            {error}
                        </Alert>
                    )}

                    <LoginForm onSubmit={handleLogin} loading={loading} />

                    <Box sx={{ mt: 2, textAlign: 'center' }}>
                        <Link component={RouterLink} to="/register" variant="body2">
                            Don't have an account? Sign Up
                        </Link>
                    </Box>
                </Paper>
            </Box>
        </Container>
    );
};
</file>

<file path="frontend/src/pages/Profile.tsx">
import React, { useState } from 'react';
import {
    Container,
    Paper,
    Typography,
    TextField,
    Button,
    Box,
    Alert,
    Divider
} from '@mui/material';
import { useAuth } from '../hooks/useAuth';
import authService from '../services/auth.service';

export const Profile: React.FC = () => {
    const { user, updateUser } = useAuth();
    const [editing, setEditing] = useState(false);
    const [name, setName] = useState(user?.name || '');
    const [email, setEmail] = useState(user?.email || '');
    const [currentPassword, setCurrentPassword] = useState('');
    const [newPassword, setNewPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [message, setMessage] = useState<{ type: 'success' | 'error'; text: string } | null>(null);

    const handleUpdateProfile = async () => {
        try {
            const updatedUser = await authService.updateProfile({ name, email });
            updateUser(updatedUser);
            setMessage({ type: 'success', text: 'Profile updated successfully!' });
            setEditing(false);
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Failed to update profile' });
        }
    };

    const handleUpdatePassword = async () => {
        if (newPassword !== confirmPassword) {
            setMessage({ type: 'error', text: 'Passwords do not match' });
            return;
        }

        try {
            await authService.updatePassword(currentPassword, newPassword);
            setMessage({ type: 'success', text: 'Password updated successfully!' });
            setCurrentPassword('');
            setNewPassword('');
            setConfirmPassword('');
        } catch (error: any) {
            setMessage({ type: 'error', text: error.message || 'Failed to update password' });
        }
    };

    return (
        <Container maxWidth="md">
            <Typography variant="h4" gutterBottom>
                Profile
            </Typography>

            {message && (
                <Alert severity={message.type} sx={{ mb: 2 }} onClose={() => setMessage(null)}>
                    {message.text}
                </Alert>
            )}

            <Paper sx={{ p: 3, mb: 3 }}>
                <Typography variant="h6" gutterBottom>
                    Personal Information
                </Typography>
                <Box sx={{ mt: 2 }}>
                    <TextField
                        fullWidth
                        label="Name"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        disabled={!editing}
                        sx={{ mb: 2 }}
                    />
                    <TextField
                        fullWidth
                        label="Email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        disabled={!editing}
                        sx={{ mb: 2 }}
                    />
                    <Box sx={{ display: 'flex', gap: 2 }}>
                        {editing ? (
                            <>
                                <Button variant="contained" onClick={handleUpdateProfile}>
                                    Save Changes
                                </Button>
                                <Button variant="outlined" onClick={() => setEditing(false)}>
                                    Cancel
                                </Button>
                            </>
                        ) : (
                            <Button variant="contained" onClick={() => setEditing(true)}>
                                Edit Profile
                            </Button>
                        )}
                    </Box>
                </Box>
            </Paper>

            <Paper sx={{ p: 3 }}>
                <Typography variant="h6" gutterBottom>
                    Change Password
                </Typography>
                <Box sx={{ mt: 2 }}>
                    <TextField
                        fullWidth
                        type="password"
                        label="Current Password"
                        value={currentPassword}
                        onChange={(e) => setCurrentPassword(e.target.value)}
                        sx={{ mb: 2 }}
                    />
                    <TextField
                        fullWidth
                        type="password"
                        label="New Password"
                        value={newPassword}
                        onChange={(e) => setNewPassword(e.target.value)}
                        sx={{ mb: 2 }}
                    />
                    <TextField
                        fullWidth
                        type="password"
                        label="Confirm New Password"
                        value={confirmPassword}
                        onChange={(e) => setConfirmPassword(e.target.value)}
                        sx={{ mb: 2 }}
                    />
                    <Button
                        variant="contained"
                        onClick={handleUpdatePassword}
                        disabled={!currentPassword || !newPassword || !confirmPassword}
                    >
                        Update Password
                    </Button>
                </Box>
            </Paper>
        </Container>
    );
};
</file>

<file path="frontend/src/pages/Register.tsx">
import React, { useState } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import {
    Container,
    Paper,
    Box,
    Typography,
    Link,
    Alert,
} from '@mui/material';
import { RegisterForm } from '../components/auth/RegisterForm';
import { useAuth } from '../hooks/useAuth';
import { RegisterCredentials } from '../types';

export const Register: React.FC = () => {
    const navigate = useNavigate();
    const { register } = useAuth();
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState(false);

    const handleRegister = async (data: RegisterCredentials) => {
        // Prevent double submission
        if (loading) return;

        setError(null);
        setLoading(true);

        try {
            await register(data);
            navigate('/dashboard');
        } catch (err: any) {
            console.error('Registration error:', err);
            setError(err.message || 'Failed to register');
            setLoading(false);
        }
    };

    return (
        <Container component="main" maxWidth="xs">
            <Box
                sx={{
                    marginTop: 8,
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                }}
            >
                <Paper elevation={3} sx={{ p: 4, width: '100%' }}>
                    <Typography component="h1" variant="h5" align="center">
                        Sign Up
                    </Typography>

                    {error && (
                        <Alert severity="error" sx={{ mt: 2 }}>
                            {error}
                        </Alert>
                    )}

                    <RegisterForm onSubmit={handleRegister} loading={loading} />

                    <Box sx={{ mt: 2, textAlign: 'center' }}>
                        <Link component={RouterLink} to="/login" variant="body2">
                            Already have an account? Sign In
                        </Link>
                    </Box>
                </Paper>
            </Box>
        </Container>
    );
};
</file>

<file path="frontend/src/services/api.ts">
import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';

const api = axios.create({
    baseURL: process.env.REACT_APP_API_URL || 'http://localhost:5000/api',
    headers: {
        'Content-Type': 'application/json',
    },
    withCredentials: false, // Set to true if you're using cookies
});

api.interceptors.request.use(
    (config: InternalAxiosRequestConfig) => {
        const token = localStorage.getItem('token');
        if (token && config.headers) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

api.interceptors.response.use(
    (response) => response,
    (error: AxiosError) => {
        if (error.response?.status === 401) {
            // Only redirect if we're not already on the login page
            if (!window.location.pathname.includes('/login')) {
                localStorage.removeItem('token');
                localStorage.removeItem('user');
                window.location.href = '/login';
            }
        }

        const message = (error.response?.data as any)?.message || error.message;
        return Promise.reject(new Error(message));
    }
);

export default api;
</file>

<file path="frontend/src/services/auth.service.ts">
import api from './api';
import { User, LoginCredentials, RegisterCredentials, ApiResponse } from '../types';

interface AuthResponse {
    user: User;
    token: string;
}

class AuthService {
    async login(credentials: LoginCredentials): Promise<AuthResponse> {
        const response = await api.post<ApiResponse<AuthResponse>>(
            '/auth/login',
            credentials
        );

        if (response.data.success) {
            const data = response.data as any;
            this.setSession(data.token, data.user);
            return { user: data.user, token: data.token };
        }

        throw new Error('Login failed');
    }

    async register(credentials: RegisterCredentials): Promise<AuthResponse> {
        const response = await api.post<ApiResponse<AuthResponse>>(
            '/auth/register',
            credentials
        );

        if (response.data.success) {
            const data = response.data as any;
            this.setSession(data.token, data.user);
            return { user: data.user, token: data.token };
        }

        throw new Error('Registration failed');
    }

    async getCurrentUser(): Promise<User> {
        const response = await api.get<ApiResponse<User>>('/auth/me');

        if (response.data.success && response.data.data) {
            return response.data.data;
        }

        throw new Error('Failed to get user');
    }

    async updateProfile(data: Partial<User>): Promise<User> {
        const response = await api.put<ApiResponse<User>>('/auth/updatedetails', data);

        if (response.data.success && response.data.data) {
            return response.data.data;
        }

        throw new Error('Failed to update profile');
    }

    async updatePassword(currentPassword: string, newPassword: string): Promise<void> {
        await api.put('/auth/updatepassword', {
            currentPassword,
            newPassword,
        });
    }

    logout(): void {
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        window.location.href = '/login';
    }

    private setSession(token: string, user: User): void {
        localStorage.setItem('token', token);
        localStorage.setItem('user', JSON.stringify(user));
    }

    getStoredToken(): string | null {
        return localStorage.getItem('token');
    }

    getStoredUser(): User | null {
        const userStr = localStorage.getItem('user');
        return userStr ? JSON.parse(userStr) : null;
    }
}

export default new AuthService();
</file>

<file path="frontend/src/services/expense.service.ts">
import api from './api';
import {
    Expense,
    ExpenseFormData,
    ExpenseListResponse,
    ExpenseStats,
    ApiResponse
} from '../types';

interface GetExpensesParams {
    category?: string;
    startDate?: string;
    endDate?: string;
    limit?: number;
    page?: number;
}

class ExpenseService {
    async getExpenses(params?: GetExpensesParams): Promise<ExpenseListResponse> {
        const response = await api.get<ExpenseListResponse>('/expenses', { params });
        return response.data;
    }

    async getExpense(id: string): Promise<Expense> {
        const response = await api.get<ApiResponse<Expense>>(`/expenses/${id}`);

        if (response.data.success && response.data.data) {
            return response.data.data;
        }

        throw new Error('Failed to get expense');
    }

    async createExpense(data: ExpenseFormData): Promise<Expense> {
        const response = await api.post<ApiResponse<Expense>>('/expenses', data);

        if (response.data.success && response.data.data) {
            return response.data.data;
        }

        throw new Error('Failed to create expense');
    }

    async updateExpense(id: string, data: Partial<ExpenseFormData>): Promise<Expense> {
        const response = await api.put<ApiResponse<Expense>>(`/expenses/${id}`, data);

        if (response.data.success && response.data.data) {
            return response.data.data;
        }

        throw new Error('Failed to update expense');
    }

    async deleteExpense(id: string): Promise<void> {
        await api.delete(`/expenses/${id}`);
    }

    async getExpenseStats(year?: number, month?: number): Promise<ExpenseStats> {
        const params: any = {};
        if (year) params.year = year;
        if (month) params.month = month;

        const response = await api.get<ApiResponse<ExpenseStats>>('/expenses/stats', { params });

        if (response.data.success && response.data.data) {
            return response.data.data;
        }

        throw new Error('Failed to get expense statistics');
    }

    async bulkCreateExpenses(expenses: ExpenseFormData[]): Promise<number> {
        const response = await api.post<ApiResponse<{ count: number }>>('/expenses/bulk', {
            expenses,
        });

        if (response.data.success && response.data.data) {
            return response.data.data.count;
        }

        throw new Error('Failed to bulk create expenses');
    }
}

export default new ExpenseService();
</file>

<file path="frontend/src/styles/globals.css">
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html,
body {
    height: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

#root {
    height: 100%;
}

::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: #555;
}

.flex-center {
    display: flex;
    align-items: center;
    justify-content: center;
}

.text-center {
    text-align: center;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.fade-in {
    animation: fadeIn 0.3s ease-in-out;
}

.loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
</file>

<file path="frontend/src/styles/theme.ts">
import { createTheme } from '@mui/material/styles';

export const theme = createTheme({
    palette: {
        primary: {
            main: '#4F46E5',
            light: '#6366F1',
            dark: '#4338CA',
        },
        secondary: {
            main: '#10B981',
            light: '#34D399',
            dark: '#059669',
        },
        error: {
            main: '#EF4444',
        },
        warning: {
            main: '#F59E0B',
        },
        info: {
            main: '#3B82F6',
        },
        success: {
            main: '#10B981',
        },
        background: {
            default: '#F3F4F6',
            paper: '#FFFFFF',
        },
    },
    typography: {
        fontFamily: [
            '-apple-system',
            'BlinkMacSystemFont',
            '"Segoe UI"',
            'Roboto',
            '"Helvetica Neue"',
            'Arial',
            'sans-serif',
        ].join(','),
        h1: {
            fontSize: '2.5rem',
            fontWeight: 700,
        },
        h2: {
            fontSize: '2rem',
            fontWeight: 600,
        },
        h3: {
            fontSize: '1.75rem',
            fontWeight: 600,
        },
        h4: {
            fontSize: '1.5rem',
            fontWeight: 600,
        },
        h5: {
            fontSize: '1.25rem',
            fontWeight: 600,
        },
        h6: {
            fontSize: '1rem',
            fontWeight: 600,
        },
    },
    shape: {
        borderRadius: 8,
    },
    components: {
        MuiButton: {
            styleOverrides: {
                root: {
                    textTransform: 'none',
                    fontWeight: 500,
                },
            },
        },
        MuiTextField: {
            defaultProps: {
                variant: 'outlined',
                fullWidth: true,
            },
        },
        MuiCard: {
            styleOverrides: {
                root: {
                    boxShadow: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
                },
            },
        },
    },
});
</file>

<file path="frontend/src/types/index.ts">
// User types
export interface User {
    _id: string;
    name: string;
    email: string;
    role?: 'user' | 'admin';
    isActive?: boolean;
    createdAt: string;
    updatedAt: string;
}

// Auth types
export interface AuthState {
    user: User | null;
    token: string | null;
    isAuthenticated: boolean;
    loading: boolean;
}

export interface LoginCredentials {
    email: string;
    password: string;
}

export interface RegisterCredentials {
    name: string;
    email: string;
    password: string;
}

// Expense types
export interface Expense {
    _id: string;
    user: string;
    title: string;
    amount: number;
    category: ExpenseCategory;
    description?: string;
    date: string;
    isRecurring: boolean;
    recurringInterval?: 'daily' | 'weekly' | 'monthly' | 'yearly';
    tags: string[];
    attachments?: Array<{
        filename: string;
        url: string;
        uploadedAt: string;
    }>;
    createdAt: string;
    updatedAt: string;
}

export type ExpenseCategory =
    | 'Food'
    | 'Transportation'
    | 'Housing'
    | 'Entertainment'
    | 'Healthcare'
    | 'Shopping'
    | 'Education'
    | 'Utilities'
    | 'Other';

export interface ExpenseFormData {
    title: string;
    amount: number;
    category: ExpenseCategory;
    description?: string;
    date: string;
    isRecurring: boolean;
    recurringInterval?: 'daily' | 'weekly' | 'monthly' | 'yearly';
    tags: string[];
}

// API Response types
export interface ApiResponse<T> {
    success: boolean;
    data?: T;
    message?: string;
    error?: string;
    token?: string;
    user?: User;
}

export interface PaginationInfo {
    page: number;
    limit: number;
    pages: number;
    total: number;  // Remove the ? to make it required
}

export interface ExpenseListResponse {
    success: boolean;
    count: number;
    total: number;
    totalAmount: number;
    pagination: PaginationInfo;
    data: Expense[];
}

// Statistics types
export interface CategoryStats {
    category: string;
    totalAmount: number;
    count: number;
    avgAmount: number;
}

export interface MonthlyStats {
    year: number;
    month: number;
    totalAmount: number;
    count: number;
}

export interface ExpenseStats {
    categoryStats: CategoryStats[];
    monthlyStats: MonthlyStats[];
    dateRange: {
        start: string;
        end: string;
    };
}
</file>

<file path="frontend/src/utils/constants.ts">
export const EXPENSE_CATEGORIES = [
    'Food',
    'Transportation',
    'Housing',
    'Entertainment',
    'Healthcare',
    'Shopping',
    'Education',
    'Utilities',
    'Other'
] as const;

export const RECURRING_INTERVALS = [
    { value: 'daily', label: 'Daily' },
    { value: 'weekly', label: 'Weekly' },
    { value: 'monthly', label: 'Monthly' },
    { value: 'yearly', label: 'Yearly' },
] as const;

export const CATEGORY_COLORS: Record<string, string> = {
    Food: '#FF6384',
    Transportation: '#36A2EB',
    Housing: '#FFCE56',
    Entertainment: '#4BC0C0',
    Healthcare: '#9966FF',
    Shopping: '#FF9F40',
    Education: '#FF6384',
    Utilities: '#C9CBCF',
    Other: '#969696',
};

export const MONTHS = [
    'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'
];
</file>

<file path="frontend/src/utils/helpers.ts">
import { format, parseISO, startOfMonth, endOfMonth, isValid } from 'date-fns';

export const formatCurrency = (amount: number): string => {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
    }).format(amount);
};

export const formatDate = (date: string | Date): string => {
    const parsedDate = typeof date === 'string' ? parseISO(date) : date;
    return isValid(parsedDate) ? format(parsedDate, 'MMM dd, yyyy') : '';
};

export const formatDateForInput = (date: string | Date): string => {
    const parsedDate = typeof date === 'string' ? parseISO(date) : date;
    return isValid(parsedDate) ? format(parsedDate, 'yyyy-MM-dd') : '';
};

export const getCurrentMonthRange = () => {
    const now = new Date();
    return {
        start: startOfMonth(now),
        end: endOfMonth(now),
    };
};

export const calculatePercentage = (value: number, total: number): number => {
    if (total === 0) return 0;
    return Math.round((value / total) * 100);
};

export const groupExpensesByCategory = (expenses: any[]) => {
    return expenses.reduce((acc, expense) => {
        const category = expense.category;
        if (!acc[category]) {
            acc[category] = {
                total: 0,
                count: 0,
                expenses: [],
            };
        }
        acc[category].total += expense.amount;
        acc[category].count += 1;
        acc[category].expenses.push(expense);
        return acc;
    }, {});
};

export const generateExpenseCSV = (expenses: any[]): string => {
    const headers = ['Date', 'Title', 'Category', 'Amount', 'Description'];
    const rows = expenses.map(expense => [
        formatDate(expense.date),
        expense.title,
        expense.category,
        expense.amount.toString(),
        expense.description || '',
    ]);

    const csv = [
        headers.join(','),
        ...rows.map(row => row.map(cell => `"${cell}"`).join(',')),
    ].join('\n');

    return csv;
};

export const downloadFile = (content: string, filename: string, type = 'text/csv') => {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
};
</file>

<file path="frontend/src/utils/validators.ts">
import * as yup from 'yup';
import { EXPENSE_CATEGORIES } from './constants';

export const loginSchema = yup.object().shape({
    email: yup
        .string()
        .email('Invalid email address')
        .required('Email is required'),
    password: yup
        .string()
        .min(6, 'Password must be at least 6 characters')
        .required('Password is required'),
});

export const registerSchema = yup.object().shape({
    name: yup
        .string()
        .min(2, 'Name must be at least 2 characters')
        .max(50, 'Name cannot exceed 50 characters')
        .required('Name is required'),
    email: yup
        .string()
        .email('Invalid email address')
        .required('Email is required'),
    password: yup
        .string()
        .min(6, 'Password must be at least 6 characters')
        .required('Password is required'),
    confirmPassword: yup
        .string()
        .oneOf([yup.ref('password')], 'Passwords must match')
        .required('Please confirm your password'),
});

export const expenseSchema = yup.object().shape({
    title: yup
        .string()
        .max(100, 'Title cannot exceed 100 characters')
        .required('Title is required'),
    amount: yup
        .number()
        .positive('Amount must be positive')
        .required('Amount is required'),
    category: yup
        .string()
        .oneOf(EXPENSE_CATEGORIES as unknown as string[])
        .required('Category is required'),
    date: yup
        .string()
        .required('Date is required'),
    description: yup
        .string()
        .max(500, 'Description cannot exceed 500 characters'),
    isRecurring: yup.boolean().required(),
    recurringInterval: yup
        .string()
        .when('isRecurring', {
            is: true,
            then: (schema) => schema.required('Recurring interval is required'),
        }),
    tags: yup.array().of(yup.string().required()).required()
});

export const updatePasswordSchema = yup.object().shape({
    currentPassword: yup
        .string()
        .required('Current password is required'),
    newPassword: yup
        .string()
        .min(6, 'New password must be at least 6 characters')
        .required('New password is required'),
    confirmNewPassword: yup
        .string()
        .oneOf([yup.ref('newPassword')], 'Passwords must match')
        .required('Please confirm your new password'),
});
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "strictNullChecks": false,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"]
}
</file>

<file path="package.json">
{
  "name": "expense-tracker-fullstack",
  "version": "1.0.0",
  "description": "Full-stack expense tracking application",
  "scripts": {
    "install:all": "cd backend && npm install && cd ../frontend && npm install",
    "dev": "concurrently \"npm run dev:backend\" \"npm run dev:frontend\"",
    "dev:backend": "cd backend && npm run dev",
    "dev:frontend": "cd frontend && npm start",
    "start:backend": "cd backend && npm start",
    "start:frontend": "cd frontend && npm start",
    "build": "cd frontend && npm run build",
    "test": "cd backend && npm test && cd frontend && npm test -- --watchAll=false"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/
*/node_modules/

# Environment variables
.env
.env.local
.env.production
.env.development

# Production builds
build/
dist/

# IDE files
.idea/
.vscode/
*.swp
*.swo

# OS files
Thumbs.db
Desktop.ini
.DS_Store

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Testing
coverage/

# Misc
.eslintcache
.parcel-cache
.next
.nuxt
.cache
</file>

<file path="backend/.env.example">
PORT=5000
NODE_ENV=development
MONGODB_URI=mongodb://localhost:27017/your-database-name
JWT_SECRET=your-secret-key-here
JWT_EXPIRE=30d
CLIENT_URL=http://localhost:3000
</file>

<file path="backend/api-tests.http">
### Health Check
GET http://localhost:5000/health

### Register New User
POST http://localhost:5000/api/auth/register
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "password123"
}

### Login (save the token from response)
POST http://localhost:5000/api/auth/login
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "password123"
}

### Get Current User
GET http://localhost:5000/api/auth/me
Authorization: Bearer YOUR_TOKEN_HERE

### Create Expense
POST http://localhost:5000/api/expenses
Authorization: Bearer YOUR_TOKEN_HERE
Content-Type: application/json

{
  "title": "Grocery Shopping",
  "amount": 125.50,
  "category": "Food",
  "description": "Weekly groceries from Walmart",
  "date": "2024-06-15"
}

### Get All Expenses
GET http://localhost:5000/api/expenses
Authorization: Bearer YOUR_TOKEN_HERE

### Get Expense Statistics
GET http://localhost:5000/api/expenses/stats
Authorization: Bearer YOUR_TOKEN_HERE
</file>

<file path="backend/src/app.js">
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const path = require('path');

// Load environment variables
dotenv.config({ path: path.join(__dirname, '../.env') });

// Import configurations
const corsOptions = require('./config/cors');

// Import routes
const authRoutes = require('./routes/authRoutes');
const expenseRoutes = require('./routes/expenseRoutes');

// Import middleware
const errorHandler = require('./middleware/errorHandler');

// Create Express app
const app = express();

// Trust proxy
app.set('trust proxy', 1);

// Middleware - IMPORTANT: cors should be before other middleware
app.use(cors({
    origin: 'http://localhost:3000',
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    optionsSuccessStatus: 200
}));

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Request logging in development
if (process.env.NODE_ENV === 'development') {
    app.use((req, res, next) => {
        console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
        next();
    });
}

// Health check endpoint
app.get('/health', (req, res) => {
    res.json({
        status: 'OK',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        environment: process.env.NODE_ENV,
    });
});

// Root endpoint
app.get('/', (req, res) => {
    res.json({ message: 'Expense Tracker API' });
});

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/expenses', expenseRoutes);

// 404 handler
app.use((req, res, next) => {
    res.status(404).json({
        success: false,
        message: `Route ${req.originalUrl} not found`,
    });
});

// Global error handler
app.use(errorHandler);

module.exports = app;
</file>

<file path="backend/src/config/cors.js">
/**
 * CORS (Cross-Origin Resource Sharing) configuration
 * Allows frontend to communicate with backend
 */
const corsOptions = {
    origin: function (origin, callback) {
        // Allowed origins
        const allowedOrigins = [
            'http://localhost:3000',      // React development server
            'http://localhost:5000',      // Backend (for testing)
            process.env.CLIENT_URL,       // Production frontend URL
        ].filter(Boolean); // Remove any undefined values

        // Allow requests with no origin (mobile apps, Postman)
        if (!origin) return callback(null, true);

        if (allowedOrigins.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true, // Allow cookies to be sent
    optionsSuccessStatus: 200, // For legacy browser support
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
};

module.exports = corsOptions;
</file>

<file path="backend/src/config/database.js">
const mongoose = require('mongoose');

/**
 * Connects to MongoDB database
 * Uses connection string from environment variables
 * Implements retry logic for resilience
 */
const connectDB = async () => {
    try {
        // Remove deprecated options - MongoDB driver 4.0+ doesn't need them
        const conn = await mongoose.connect(process.env.MONGODB_URI);

        console.log(` MongoDB Connected: ${conn.connection.host}`);

        // Handle connection events
        mongoose.connection.on('error', (err) => {
            console.error(` MongoDB connection error: ${err}`);
        });

        mongoose.connection.on('disconnected', () => {
            console.warn('  MongoDB disconnected');
        });

        // Graceful shutdown
        process.on('SIGINT', async () => {
            await mongoose.connection.close();
            console.log('MongoDB connection closed through app termination');
            process.exit(0);
        });

    } catch (error) {
        console.error(` Error: ${error.message}`);
        // Exit process with failure
        process.exit(1);
    }
};

module.exports = connectDB;
</file>

<file path="backend/src/middleware/errorHandler.js">
/**
 * Global error handling middleware
 * Catches all errors and sends appropriate response
 */
const errorHandler = (err, req, res, next) => {
    let error = { ...err };
    error.message = err.message;

    // Log error for debugging
    console.error(err);

    // Mongoose bad ObjectId
    if (err.name === 'CastError') {
        const message = 'Resource not found';
        error = { message, statusCode: 404 };
    }

    // Mongoose duplicate key
    if (err.code === 11000) {
        const field = Object.keys(err.keyValue)[0];
        const message = `${field} already exists`;
        error = { message, statusCode: 400 };
    }

    // Mongoose validation error
    if (err.name === 'ValidationError') {
        const message = Object.values(err.errors)
            .map(val => val.message)
            .join(', ');
        error = { message, statusCode: 400 };
    }

    // JWT errors
    if (err.name === 'JsonWebTokenError') {
        const message = 'Invalid token';
        error = { message, statusCode: 401 };
    }

    if (err.name === 'TokenExpiredError') {
        const message = 'Token expired';
        error = { message, statusCode: 401 };
    }

    res.status(error.statusCode || 500).json({
        success: false,
        message: error.message || 'Server Error',
        ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
    });
};

module.exports = errorHandler;
</file>

<file path="backend/src/middleware/validation.js">
const { validationResult } = require('express-validator');

/**
 * Validation middleware
 * Checks for validation errors from express-validator
 */
exports.validate = (req, res, next) => {
    const errors = validationResult(req);

    if (!errors.isEmpty()) {
        const errorMessages = errors.array().map(error => ({
            field: error.param,
            message: error.msg,
        }));

        return res.status(400).json({
            success: false,
            errors: errorMessages,
        });
    }

    next();
};
</file>

<file path="backend/test-api.http">
### Health Check
GET http://localhost:5000/health

### Register User
POST http://localhost:5000/api/auth/register
Content-Type: application/json

{
  "name": "Test User",
  "email": "test@example.com",
  "password": "password123"
}

### Login User
POST http://localhost:5000/api/auth/login
Content-Type: application/json

{
  "email": "test@example.com",
  "password": "password123"
}

### Get Current User (need to add token from login response)
GET http://localhost:5000/api/auth/me
Authorization: Bearer YOUR_TOKEN_HERE

### Create Expense (need token)
POST http://localhost:5000/api/expenses
Authorization: Bearer YOUR_TOKEN_HERE
Content-Type: application/json

{
  "title": "Grocery Shopping",
  "amount": 85.50,
  "category": "Food",
  "description": "Weekly groceries from Walmart",
  "date": "2024-01-15"
}

### Get All Expenses (need token)
GET http://localhost:5000/api/expenses
Authorization: Bearer YOUR_TOKEN_HERE
</file>

<file path="backend/test-mongodb-connection.js">
const mongoose = require('mongoose');

async function testMongoDB() {
    console.log(' Testing MongoDB connection...\n');

    try {
        // Connect to MongoDB
        await mongoose.connect('mongodb://localhost:27017/expense-tracker-test');

        console.log(' Successfully connected to MongoDB!');
        console.log(' Connection details:');
        console.log(`   - Host: ${mongoose.connection.host}`);
        console.log(`   - Port: ${mongoose.connection.port}`);
        console.log(`   - Database: ${mongoose.connection.name}`);

        // Create a test collection and document
        const TestSchema = new mongoose.Schema({
            message: String,
            timestamp: { type: Date, default: Date.now }
        });

        const Test = mongoose.model('Test', TestSchema);

        // Create a test document
        const testDoc = await Test.create({
            message: 'MongoDB is working perfectly!'
        });

        console.log('\n Test document created:', testDoc);

        // Clean up
        await Test.deleteMany({});
        await mongoose.connection.close();

        console.log('\n MongoDB test completed successfully!');
        console.log(' You can proceed with development.\n');

    } catch (error) {
        console.error(' Connection failed:', error.message);
        console.error('\nTroubleshooting tips:');
        console.error('1. Check if MongoDB service is running: Get-Service MongoDB');
        console.error('2. Try connecting with MongoDB Compass');
        console.error('3. Check Windows Firewall settings');
    }
}

// Run the test
testMongoDB();
</file>

<file path="frontend/package.json">
{
  "name": "expense-tracker-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@babel/runtime": "^7.23.0",
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "@hookform/resolvers": "^3.3.2",
    "@mui/icons-material": "^5.14.19",
    "@mui/material": "^5.14.20",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "@types/node": "^16.18.68",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@types/react-router-dom": "^5.3.3",
    "@types/recharts": "^1.8.29",
    "axios": "^1.6.2",
    "date-fns": "^2.30.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.48.2",
    "react-router-dom": "^6.20.1",
    "react-scripts": "^5.0.1",
    "recharts": "^2.10.3",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4",
    "yup": "^1.3.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="backend/package.json">
{
  "name": "expense-tracker-backend",
  "version": "1.0.0",
  "description": "Backend API for expense tracker application",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "keywords": [
    "expense",
    "tracker",
    "api",
    "nodejs",
    "express"
  ],
  "author": "Your Name",
  "license": "MIT",
  "engines": {
    "node": ">=14.0.0"
  },
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-validator": "^7.2.1",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.15.2"
  },
  "devDependencies": {
    "jest": "^30.0.0",
    "nodemon": "^3.1.10",
    "supertest": "^7.1.1"
  }
}
</file>

<file path="backend/src/controllers/authController.js">
const User = require('../models/User');
const jwt = require('jsonwebtoken');

/**
 * Generate JWT token
 * @param {string} id - User ID
 * @returns {string} JWT token
 */
const generateToken = (id) => {
    return jwt.sign(
        { id },
        process.env.JWT_SECRET,
        { expiresIn: process.env.JWT_EXPIRE }
    );
};

/**
 * @desc    Register new user
 * @route   POST /api/auth/register
 * @access  Public
 */
exports.register = async (req, res) => {
    console.log('Register endpoint hit');
    console.log('Request body:', req.body);

    try {
        const { name, email, password } = req.body;

        // Check if all fields are provided
        if (!name || !email || !password) {
            return res.status(400).json({
                success: false,
                message: 'Please provide all required fields'
            });
        }

        // Check if user already exists
        const existingUser = await User.findOne({ email });
        if (existingUser) {
            return res.status(400).json({
                success: false,
                message: 'User already exists with this email'
            });
        }

        // Create user
        const user = await User.create({
            name,
            email,
            password
        });

        // Generate token
        const token = generateToken(user._id);

        console.log('User created successfully:', user.email);

        res.status(201).json({
            success: true,
            token,
            user: {
                id: user._id,
                name: user.name,
                email: user.email
            }
        });
    } catch (error) {
        console.error('Register error:', error);
        res.status(400).json({
            success: false,
            message: error.message
        });
    }
};

/**
 * @desc    Login user
 * @route   POST /api/auth/login
 * @access  Public
 */
exports.login = async (req, res, next) => {
    try {
        const { email, password } = req.body;

        // Check if email and password are provided
        if (!email || !password) {
            return res.status(400).json({
                success: false,
                message: 'Please provide email and password',
            });
        }

        // Find user by email and include password
        const user = await User.findOne({ email }).select('+password');

        if (!user) {
            return res.status(401).json({
                success: false,
                message: 'Invalid credentials',
            });
        }

        // Check if password matches
        const isPasswordValid = await user.comparePassword(password);

        if (!isPasswordValid) {
            return res.status(401).json({
                success: false,
                message: 'Invalid credentials',
            });
        }

        // Update last login
        user.lastLogin = new Date();
        await user.save();

        // Generate token
        const token = generateToken(user._id);

        res.status(200).json({
            success: true,
            token,
            user,
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Get current user
 * @route   GET /api/auth/me
 * @access  Private
 */
exports.getMe = async (req, res, next) => {
    res.status(200).json({
        success: true,
        user: req.user,
    });
};

/**
 * @desc    Update user details
 * @route   PUT /api/auth/updatedetails
 * @access  Private
 */
exports.updateDetails = async (req, res, next) => {
    try {
        const fieldsToUpdate = {
            name: req.body.name,
            email: req.body.email,
        };

        const user = await User.findByIdAndUpdate(
            req.user.id,
            fieldsToUpdate,
            {
                new: true,
                runValidators: true,
            }
        );

        res.status(200).json({
            success: true,
            user,
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Update password
 * @route   PUT /api/auth/updatepassword
 * @access  Private
 */
exports.updatePassword = async (req, res, next) => {
    try {
        const user = await User.findById(req.user.id).select('+password');

        // Check current password
        if (!(await user.comparePassword(req.body.currentPassword))) {
            return res.status(401).json({
                success: false,
                message: 'Current password is incorrect',
            });
        }

        user.password = req.body.newPassword;
        await user.save();

        const token = generateToken(user._id);

        res.status(200).json({
            success: true,
            token,
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Logout user
 * @route   POST /api/auth/logout
 * @access  Private
 */
exports.logout = async (req, res, next) => {
    // Since we're using JWT, we just tell the client to remove the token
    res.status(200).json({
        success: true,
        message: 'Logged out successfully',
    });
};
</file>

<file path="backend/src/controllers/expenseController.js">
const Expense = require('../models/Expense');

/**
 * @desc    Get all expenses for logged in user
 * @route   GET /api/expenses
 * @access  Private
 */
exports.getExpenses = async (req, res, next) => {
    try {
        // Parse query parameters
        const { category, startDate, endDate, limit = 50, page = 1 } = req.query;

        // Build query
        const query = { user: req.user.id };

        if (category) {
            query.category = category;
        }

        if (startDate || endDate) {
            query.date = {};
            if (startDate) query.date.$gte = new Date(startDate);
            if (endDate) query.date.$lte = new Date(endDate);
        }

        // Execute query with pagination
        const expenses = await Expense.find(query)
            .sort({ date: -1 })
            .limit(limit * 1)
            .skip((page - 1) * limit)
            .lean();

        // Get total count for pagination
        const count = await Expense.countDocuments(query);

        // Calculate total amount
        const totalAmount = expenses.reduce((sum, expense) => sum + expense.amount, 0);

        res.status(200).json({
            success: true,
            count: expenses.length,
            total: count,
            totalAmount,
            pagination: {
                page: Number(page),
                limit: Number(limit),
                pages: Math.ceil(count / limit),
            },
            data: expenses,
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Get single expense
 * @route   GET /api/expenses/:id
 * @access  Private
 */
exports.getExpense = async (req, res, next) => {
    try {
        const expense = await Expense.findById(req.params.id);

        if (!expense) {
            return res.status(404).json({
                success: false,
                message: 'Expense not found',
            });
        }

        // Check ownership
        if (expense.user.toString() !== req.user.id) {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to view this expense',
            });
        }

        res.status(200).json({
            success: true,
            data: expense,
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Create new expense
 * @route   POST /api/expenses
 * @access  Private
 */
exports.createExpense = async (req, res, next) => {
    try {
        // Add user to request body
        req.body.user = req.user.id;

        const expense = await Expense.create(req.body);

        res.status(201).json({
            success: true,
            data: expense,
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Update expense
 * @route   PUT /api/expenses/:id
 * @access  Private
 */
exports.updateExpense = async (req, res, next) => {
    try {
        let expense = await Expense.findById(req.params.id);

        if (!expense) {
            return res.status(404).json({
                success: false,
                message: 'Expense not found',
            });
        }

        // Check ownership
        if (expense.user.toString() !== req.user.id) {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to update this expense',
            });
        }

        // Update expense
        expense = await Expense.findByIdAndUpdate(
            req.params.id,
            req.body,
            {
                new: true,
                runValidators: true,
            }
        );

        res.status(200).json({
            success: true,
            data: expense,
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Delete expense
 * @route   DELETE /api/expenses/:id
 * @access  Private
 */
exports.deleteExpense = async (req, res, next) => {
    try {
        const expense = await Expense.findById(req.params.id);

        if (!expense) {
            return res.status(404).json({
                success: false,
                message: 'Expense not found',
            });
        }

        // Check ownership
        if (expense.user.toString() !== req.user.id) {
            return res.status(403).json({
                success: false,
                message: 'Not authorized to delete this expense',
            });
        }

        await expense.deleteOne();

        res.status(200).json({
            success: true,
            message: 'Expense deleted successfully',
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Get expense statistics
 * @route   GET /api/expenses/stats
 * @access  Private
 */
exports.getExpenseStats = async (req, res, next) => {
    try {
        const { year, month } = req.query;

        // Date range for statistics
        let startDate, endDate;

        if (year && month) {
            startDate = new Date(year, month - 1, 1);
            endDate = new Date(year, month, 0);
        } else if (year) {
            startDate = new Date(year, 0, 1);
            endDate = new Date(year, 11, 31);
        } else {
            // Current year by default
            const currentYear = new Date().getFullYear();
            startDate = new Date(currentYear, 0, 1);
            endDate = new Date(currentYear, 11, 31);
        }

        // Get statistics by category
        const categoryStats = await Expense.getStatsByUser(
            req.user._id,
            startDate,
            endDate
        );

        // Get monthly statistics
        const monthlyStats = await Expense.aggregate([
            {
                $match: {
                    user: req.user._id,
                    date: { $gte: startDate, $lte: endDate },
                },
            },
            {
                $group: {
                    _id: {
                        year: { $year: '$date' },
                        month: { $month: '$date' },
                    },
                    totalAmount: { $sum: '$amount' },
                    count: { $count: {} },
                },
            },
            {
                $project: {
                    _id: 0,
                    year: '$_id.year',
                    month: '$_id.month',
                    totalAmount: { $divide: ['$totalAmount', 100] },
                    count: 1,
                },
            },
            { $sort: { year: 1, month: 1 } },
        ]);

        res.status(200).json({
            success: true,
            data: {
                categoryStats,
                monthlyStats,
                dateRange: {
                    start: startDate,
                    end: endDate,
                },
            },
        });
    } catch (error) {
        next(error);
    }
};

/**
 * @desc    Bulk create expenses
 * @route   POST /api/expenses/bulk
 * @access  Private
 */
exports.bulkCreateExpenses = async (req, res, next) => {
    try {
        const { expenses } = req.body;

        if (!Array.isArray(expenses) || expenses.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'Please provide an array of expenses',
            });
        }

        // Add user to each expense
        const expensesWithUser = expenses.map(expense => ({
            ...expense,
            user: req.user.id,
        }));

        const createdExpenses = await Expense.insertMany(expensesWithUser, {
            ordered: false, // Continue on error
            rawResult: true,
        });

        res.status(201).json({
            success: true,
            count: createdExpenses.insertedCount,
            data: createdExpenses.ops,
        });
    } catch (error) {
        next(error);
    }
};
</file>

<file path="backend/src/middleware/auth.js">
const jwt = require('jsonwebtoken');
const User = require('../models/User');

/**
 * Authentication middleware
 * Protects routes that require login
 */
exports.protect = async (req, res, next) => {
    try {
        let token;

        // Check for token in Authorization header
        if (req.headers.authorization &&
            req.headers.authorization.startsWith('Bearer')) {
            // Extract token from "Bearer TOKEN"
            token = req.headers.authorization.split(' ')[1];
        }

        // Check if token exists
        if (!token) {
            return res.status(401).json({
                success: false,
                message: 'Not authorized to access this route',
            });
        }

        try {
            // Verify token
            const decoded = jwt.verify(token, process.env.JWT_SECRET);

            // Find user by ID from token
            req.user = await User.findById(decoded.id);

            if (!req.user) {
                return res.status(401).json({
                    success: false,
                    message: 'User no longer exists',
                });
            }

            // Check if user is active
            if (!req.user.isActive) {
                return res.status(401).json({
                    success: false,
                    message: 'User account is deactivated',
                });
            }

            next();
        } catch (err) {
            return res.status(401).json({
                success: false,
                message: 'Invalid token',
            });
        }
    } catch (error) {
        console.error('Auth middleware error:', error);
        return res.status(500).json({
            success: false,
            message: 'Server error',
        });
    }
};

/**
 * Grant access to specific roles
 * Must be used after protect middleware
 */
exports.authorize = (...roles) => {
    return (req, res, next) => {
        if (!roles.includes(req.user.role)) {
            return res.status(403).json({
                success: false,
                message: `User role '${req.user.role}' is not authorized to access this route`,
            });
        }
        next();
    };
};
</file>

<file path="backend/src/models/Expense.js">
const mongoose = require('mongoose');

/**
 * Expense Schema
 * Defines the structure of expense documents
 */
const expenseSchema = new mongoose.Schema({
    user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true, // Index for faster queries
    },
    title: {
        type: String,
        required: [true, 'Please provide expense title'],
        trim: true,
        maxLength: [100, 'Title cannot exceed 100 characters'],
    },
    amount: {
        type: Number,
        required: [true, 'Please provide expense amount'],
        min: [0, 'Amount cannot be negative'],
        // Store as cents to avoid floating point issues
        get: v => v / 100,
        set: v => Math.round(v * 100),
    },
    category: {
        type: String,
        required: [true, 'Please provide expense category'],
        enum: {
            values: [
                'Food',
                'Transportation',
                'Housing',
                'Entertainment',
                'Healthcare',
                'Shopping',
                'Education',
                'Utilities',
                'Insurance',
                'Savings',
                'Other'
            ],
            message: '{VALUE} is not a valid category',
        },
    },
    description: {
        type: String,
        maxLength: [500, 'Description cannot exceed 500 characters'],
        default: '',
    },
    date: {
        type: Date,
        required: [true, 'Please provide expense date'],
        default: Date.now,
        index: true, // Index for date-based queries
    },
    isRecurring: {
        type: Boolean,
        default: false,
    },
    recurringInterval: {
        type: String,
        enum: ['daily', 'weekly', 'monthly', 'yearly'],
        required: function() { return this.isRecurring; },
    },
    tags: [{
        type: String,
        trim: true,
        lowercase: true,
    }],
    attachments: [{
        filename: String,
        url: String,
        uploadedAt: {
            type: Date,
            default: Date.now,
        },
    }],
}, {
    timestamps: true,
    toJSON: { getters: true }, // Apply getters when converting to JSON
});

// Compound indexes for complex queries
expenseSchema.index({ user: 1, date: -1 });
expenseSchema.index({ user: 1, category: 1 });
expenseSchema.index({ user: 1, 'tags': 1 });

/**
 * Virtual for formatted amount
 * Provides amount as currency string
 */
expenseSchema.virtual('formattedAmount').get(function() {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
    }).format(this.amount);
});

/**
 * Static method to get expense statistics
 * Available on the model itself
 */
expenseSchema.statics.getStatsByUser = async function(userId, startDate, endDate) {
    const match = { user: userId };

    if (startDate || endDate) {
        match.date = {};
        if (startDate) match.date.$gte = startDate;
        if (endDate) match.date.$lte = endDate;
    }

    const stats = await this.aggregate([
        { $match: match },
        {
            $group: {
                _id: '$category',
                totalAmount: { $sum: '$amount' },
                count: { $count: {} },
                avgAmount: { $avg: '$amount' },
            },
        },
        {
            $project: {
                category: '$_id',
                totalAmount: { $divide: ['$totalAmount', 100] },
                count: 1,
                avgAmount: { $divide: ['$avgAmount', 100] },
                _id: 0,
            },
        },
        { $sort: { totalAmount: -1 } },
    ]);

    return stats;
};

// Create and export model
const Expense = mongoose.model('Expense', expenseSchema);
module.exports = Expense;
</file>

<file path="backend/src/models/User.js">
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

/**
 * User Schema
 * Defines the structure of user documents in MongoDB
 */
const userSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide a name'],
        trim: true,
        maxLength: [50, 'Name cannot be more than 50 characters'],
    },
    email: {
        type: String,
        required: [true, 'Please provide an email'],
        unique: true,
        lowercase: true,
        trim: true,
        match: [
            /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/,
            'Please provide a valid email',
        ],
    },
    password: {
        type: String,
        required: [true, 'Please provide a password'],
        minLength: [6, 'Password must be at least 6 characters'],
        select: false, // Don't include password in queries by default
    },
    avatar: {
        type: String,
        default: null,
    },
    role: {
        type: String,
        enum: ['user', 'admin'],
        default: 'user',
    },
    isActive: {
        type: Boolean,
        default: true,
    },
    lastLogin: {
        type: Date,
        default: null,
    },
    passwordResetToken: String,
    passwordResetExpire: Date,
}, {
    timestamps: true, // Adds createdAt and updatedAt automatically
});

// Indexes for better query performance
userSchema.index({ createdAt: -1 });

/**
 * Hash password before saving
 * This runs automatically before save()
 */
userSchema.pre('save', async function(next) {
    // Only hash if password is modified
    if (!this.isModified('password')) {
        return next();
    }

    // Generate salt and hash password
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
});

/**
 * Instance method to check password
 * Available on all user documents
 */
userSchema.methods.comparePassword = async function(candidatePassword) {
    return await bcrypt.compare(candidatePassword, this.password);
};

/**
 * Instance method to get public profile
 * Removes sensitive fields
 */
userSchema.methods.toJSON = function() {
    const user = this.toObject();
    delete user.password;
    delete user.passwordResetToken;
    delete user.passwordResetExpire;
    delete user.__v;
    return user;
};

// Create and export model
const User = mongoose.model('User', userSchema);
module.exports = User;
</file>

<file path="backend/src/routes/authRoutes.js">
const express = require('express');
const { body } = require('express-validator');
const {
    register,
    login,
    getMe,
    updateDetails,
    updatePassword,
    logout,
} = require('../controllers/authController');
const { protect } = require('../middleware/auth');
const { validate } = require('../middleware/validation');

const router = express.Router();

// Validation rules
const registerValidation = [
    body('name')
        .trim()
        .notEmpty().withMessage('Name is required')
        .isLength({ min: 2, max: 50 }).withMessage('Name must be between 2 and 50 characters'),
    body('email')
        .trim()
        .notEmpty().withMessage('Email is required')
        .isEmail().withMessage('Please provide a valid email')
        .normalizeEmail(),
    body('password')
        .notEmpty().withMessage('Password is required')
        .isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
];

const loginValidation = [
    body('email')
        .trim()
        .notEmpty().withMessage('Email is required')
        .isEmail().withMessage('Please provide a valid email')
        .normalizeEmail(),
    body('password')
        .notEmpty().withMessage('Password is required'),
];

const updatePasswordValidation = [
    body('currentPassword')
        .notEmpty().withMessage('Current password is required'),
    body('newPassword')
        .notEmpty().withMessage('New password is required')
        .isLength({ min: 6 }).withMessage('New password must be at least 6 characters'),
];

// Public routes
router.post('/register', registerValidation, validate, register);
router.post('/login', loginValidation, validate, login);

// Protected routes
router.get('/me', protect, getMe);
router.put('/updatedetails', protect, updateDetails);
router.put('/updatepassword', protect, updatePasswordValidation, validate, updatePassword);
router.post('/logout', protect, logout);

module.exports = router;
</file>

<file path="backend/src/routes/expenseRoutes.js">
const express = require('express');
const { body, query } = require('express-validator');
const {
    getExpenses,
    getExpense,
    createExpense,
    updateExpense,
    deleteExpense,
    getExpenseStats,
    bulkCreateExpenses,
} = require('../controllers/expenseController');
const { protect } = require('../middleware/auth');
const { validate } = require('../middleware/validation');

const router = express.Router();

// Validation rules
const expenseValidation = [
    body('title')
        .trim()
        .notEmpty().withMessage('Title is required')
        .isLength({ max: 100 }).withMessage('Title cannot exceed 100 characters'),
    body('amount')
        .notEmpty().withMessage('Amount is required')
        .isFloat({ min: 0 }).withMessage('Amount must be a positive number'),
    body('category')
        .notEmpty().withMessage('Category is required')
        .isIn([
            'Food',
            'Transportation',
            'Housing',
            'Entertainment',
            'Healthcare',
            'Shopping',
            'Education',
            'Utilities',
            'Insurance',
            'Savings',
            'Other',
        ]).withMessage('Invalid category'),
    body('date')
        .optional()
        .isISO8601().withMessage('Invalid date format'),
    body('description')
        .optional()
        .trim()
        .isLength({ max: 500 }).withMessage('Description cannot exceed 500 characters'),
];

// All routes require authentication
router.use(protect);

// Routes
router.route('/')
    .get(getExpenses)
    .post(expenseValidation, validate, createExpense);

router.route('/bulk')
    .post(bulkCreateExpenses);

router.route('/stats')
    .get(getExpenseStats);

router.route('/:id')
    .get(getExpense)
    .put(expenseValidation, validate, updateExpense)
    .delete(deleteExpense);

module.exports = router;
</file>

<file path="backend/src/server.js">
const app = require('./app');
const connectDB = require('./config/database');

// Get port from environment
const PORT = process.env.PORT || 5000;

// Start server
const startServer = async () => {
    try {
        // Connect to database first
        await connectDB();

        // Then start listening
        const server = app.listen(PORT, () => {
            console.log(` Server running on port ${PORT}`);
            console.log(` Environment: ${process.env.NODE_ENV}`);
            console.log(` Health check: http://localhost:${PORT}/health`);
        });

        // Handle graceful shutdown
        process.on('SIGTERM', () => {
            console.log('SIGTERM signal received: closing HTTP server');
            server.close(() => {
                console.log('HTTP server closed');
            });
        });

    } catch (error) {
        console.error('Failed to start server:', error);
        process.exit(1);
    }
};

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
    console.error('UNHANDLED REJECTION!  Shutting down...');
    console.error(err);
    process.exit(1);
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
    console.error('UNCAUGHT EXCEPTION!  Shutting down...');
    console.error(err);
    process.exit(1);
});

// Start the server
startServer();
</file>

</files>
